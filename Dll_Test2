

#include <stdio.h>
#include <io.h>
#include <Windows.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <tchar.h>
#include <conio.h>
#include <stdlib.h>
#define FALSE 0
#define TRUE 1

//inputs cliente
#define KEY_UP 1
#define KEY_DOWN 2
#define KEY_LEFT 3
#define KEY_RIGHT 4
#define KEY_SPACE 5
#define KEY_EXIT 6
//nomes
#define SEMIN TEXT("SemProdutor")
#define SEMOUT TEXT("SEMConsumidor")
#define sharedMemName TEXT("MemPartilhada")
#define EventCliCanRead TEXT("ClienteVaiLer")
#define EventSerCanRead TEXT("ServidorVaiLer")


//tamanhos
#define BUF_TAM 2
#define SM_SIZE 200000

//handles sync
HANDLE hmutex, hSEMempty, hSEMfull;
HANDLE hSMClientCanRead, hSMServerCanRead;
HANDLE hMapFile;
LPCTSTR pBufConfig, pCircularBuf, pCircularInfo;

typedef struct
{
	int bufReadIndex;
	int bufWriteIndex;
}CircularBufferInfo;

 typedef struct {

	int tecla;

}infoCliente;


//sem_t  mutex, empty, full;
//empty: semaforo utilizado pra controlar os sinais relativos as posicoes vazias no buffer
//full: semaforo utilizado pra controlar os sinais relativos as posicoes preenchidas no buffer
//mutex: semaforo bin√°rio utilizado p/ garantir exclusao mutua na regiao critica  

int lo, hi, count;
infoCliente infoCli[BUF_TAM];


// CircularBuffer: utilizado para armazenar os dados produzidos pelo produtor e consumidos pelo consumidor
//lo: proxima posicao cheia
//hi: proxima posicao vazia
//count: usado para controlar a quantidade de dados presentes no buffer


//cliente
int leComando() {

	int KEY_code = 0;

	while (KEY_code != KEY_EXIT)
	{
		if (kbhit())
		{
			KEY_code = getch();
			//printf("KEY_code = %i \n", KEY_code);

			switch (KEY_code)
			{
			case KEY_LEFT:
				//move para esquerda
				break;

			case KEY_RIGHT:
				//Move para direita                
				break;

			case KEY_UP:
				//Do something                     
				break;

			case KEY_DOWN:
				//Do something                     
				break;

			case KEY_SPACE:
				//Dispara                 
				break;

			}

		}
	}

	return 0;

	

}


void *producer(void *);
void *consumer(void *);

int onServerCreate()
{

	CircularBufferInfo cbuffer;
	hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
		0, SM_SIZE, sharedMemName);
	if (hMapFile == NULL)
	{
		_tprintf(TEXT("Could not create file mapping object (%d).\n"),
			GetLastError());
		return 0;
	}

	pBufConfig = (LPTSTR)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (pBufConfig == NULL)
	{
		CloseHandle(hMapFile);
		_tprintf(TEXT("Could not map view of file (%d).\n"),
			GetLastError());
		return 0;
	}


	pCircularInfo= pBufConfig + sizeof(infoCliente);


	cbuffer.bufReadIndex = 0;
	cbuffer.bufWriteIndex = 0;


	hSMServerCanRead = CreateEvent(NULL, TRUE, FALSE, EventSerCanRead);
	if (hSMServerCanRead == NULL)
	{
		UnmapViewOfFile(pBufConfig);
		CloseHandle(hMapFile);
		_tprintf(TEXT("Could not create a IO Shared Memory Event 1- (%d).\n"),
			GetLastError());
		return 0;
	}
	hSMClientCanRead = CreateEvent(NULL, TRUE, FALSE, EventCliCanRead);
	if (hSMClientCanRead == NULL)
	{
		UnmapViewOfFile(pBufConfig);
		CloseHandle(hMapFile);
		CloseHandle(hSMServerCanRead);
		_tprintf(TEXT("Could not create a IO Shared Memory Event 2- (%d).\n"),
			GetLastError());
		return 0;
	}
	


	hSEMempty = CreateSemaphore(NULL, 1, 1, SEMIN);

	if (hSEMempty == NULL) {

		_tprintf(TEXT("Erro a criar semaforo - (%d) "), GetLastError());
		return 0;

	}
	hSEMfull = CreateSemaphore(NULL, 1, 1, SEMOUT);

	if (hSEMfull == NULL) {

		_tprintf(TEXT("Erro a criar semaforo - (%d) "), GetLastError());
		return 0;

	}


	
}


